#include "common/msg.h"
#include "osdep/io.h"
#include "osdep/subprocess.h"
#include "video/out/gpu/utils.h"
#include "video/out/gxm/ra_gxm.h"

#include <libavutil/mem.h>
#include <libavutil/sha.h>
#include <psp2/gxm.h>
#include <psp2/kernel/sysmem.h>
#if HAVE_VITASHARK
#include <vitashark.h>
#endif

int __attribute__((weak)) psv_mpv_dump_shaders = false;

const struct gxm_format gxm_formats[] = {
    {"r8",      1, 1, {8},              SCE_GXM_TEXTURE_FORMAT_U8_000R,           RA_CTYPE_UNORM, true, true, true,  true},
    {"rg8",     2, 2, {8,  8},          SCE_GXM_TEXTURE_FORMAT_U8U8_GRGR,         RA_CTYPE_UNORM, true, true, true,  true},
    {"rgba8",   4, 4, {8,  8,  8,  8},  SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_RGBA,     RA_CTYPE_UNORM, true, true, true,  true},
    {"r16",     1, 2, {16},             SCE_GXM_TEXTURE_FORMAT_U16_000R,          RA_CTYPE_UNORM, true, true, true,  true},
    {"rg16",    2, 4, {16, 16},         SCE_GXM_TEXTURE_FORMAT_U16U16_GRGR,       RA_CTYPE_UNORM, true, true, true,  true},
    {"rgba16",  4, 8, {16, 16, 16, 16}, SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_RGBA, RA_CTYPE_UNORM, true, true, true,  true},
    {"r32ui",   1, 4, {32},             SCE_GXM_TEXTURE_FORMAT_S32_000R,          RA_CTYPE_UINT,  true, false,true,  true},
    {"r16f",    1, 2, {16},             SCE_GXM_TEXTURE_FORMAT_F16_000R,          RA_CTYPE_FLOAT, true, true, true,  true},
    {"rg16f",   2, 4, {16, 16},         SCE_GXM_TEXTURE_FORMAT_F16F16_GRGR,       RA_CTYPE_FLOAT, true, true, true,  true},
    {"rgba16f", 4, 8, {16, 16, 16, 16}, SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_RGBA, RA_CTYPE_FLOAT, true, true, true,  true},
    {"r32f",    1, 4, {32},             SCE_GXM_TEXTURE_FORMAT_F32_000R,          RA_CTYPE_FLOAT, true, true, true,  true},
    {"rg32f",   2, 8, {32, 32},         SCE_GXM_TEXTURE_FORMAT_F32F32_GRGR,       RA_CTYPE_FLOAT, true, true, true,  true},
    {"bgra8",   4, 4, {8,  8,  8,  8},  SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_BGRA,     RA_CTYPE_UNORM, true, true, true,  false},
    {"bgrx8",   3, 4, {8,  8,  8},      SCE_GXM_TEXTURE_FORMAT_U8U8U8X8_BGR1,     RA_CTYPE_UNORM, true, true, false, false},
};

static void *gxm_alloc(SceKernelMemBlockType type, SceGxmMemoryAttribFlags gpu_attrib, size_t size, SceUID *uid) {
    SceUID memuid;
    void *addr;

    if (type == SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW)
        size = MP_ALIGN_UP(size, 256 * 1024);
    else
        size = MP_ALIGN_UP(size, 4 * 1024);

    memuid = sceKernelAllocMemBlock("gpumem", type, size, NULL);
    if (memuid < 0)
        return NULL;

    if (sceKernelGetMemBlockBase(memuid, &addr) < 0)
        return NULL;

    if (sceGxmMapMemory(addr, size, gpu_attrib) < 0) {
        sceKernelFreeMemBlock(memuid);
        return NULL;
    }

    if (uid)
        *uid = memuid;

    return addr;
}

static void gxm_free(SceUID uid) {
    void *addr;

    if (uid == 0)
        return;

    if (sceKernelGetMemBlockBase(uid, &addr) < 0)
        return;

    sceGxmUnmapMemory(addr);

    sceKernelFreeMemBlock(uid);
}

static int mpv_get_shader_hash(const char *prog, char *out) {
    uint8_t hash[32];
    struct AVSHA *sha = av_sha_alloc();
    av_sha_init(sha, 256);
    av_sha_update(sha, prog, strlen(prog));
    av_sha_final(sha, hash);
    av_free(sha);

    for (int n = 0; n < 32; n++) {
        snprintf(out + n * 2, 65 - n * 2, "%02X", hash[n]);
    }

    return 0;
}

#if HAVE_VITASHARK
static void dumpShader(const char *source, const char *type, const SceGxmProgram *program, uint32_t size) {
    char path[256];
    char sha[65];

    int need_comma = 0;
    char *buf = (char *) malloc(0x5000);
    memset(buf, 0, 0x5000);
    memcpy(buf, program, size);

    mpv_get_shader_hash(source, sha);

    snprintf(path, sizeof(path), "ux0:data/mpv_%s_%s.c", type, sha);
    FILE *fp = fopen(path, "w");
    if (fp) {
        fprintf(fp, "static const unsigned char %s%sShader[%i] = {", sha, type, size);
        for (uint32_t i = 0; i < size; ++i) {
            if (need_comma)
                fprintf(fp, ", ");
            else
                need_comma = 1;
            if ((i % 11) == 0)
                fprintf(fp, "\n\t");
            fprintf(fp, "0x%.2x", buf[i] & 0xff);
        }
        fprintf(fp, "\n};\n\n");
        fclose(fp);
    }
    free(buf);
}

static int gxm_create_shader(GxmShaderProgram *shader, SceGxmShaderPatcher *shader_patcher, const char *vshader, const char *fshader) {
    if (vshader != NULL) {
        uint32_t size = strlen(vshader);
        SceGxmProgram *p = shark_compile_shader(vshader, &size, SHARK_VERTEX_SHADER);
        if (!p) {
            shark_clear_output();
            return 0;
        }
        shader->vert_gxp = (SceGxmProgram *) malloc(size);
        sceClibMemcpy((void *) shader->vert_gxp, (void *) p, size);
        shark_clear_output();
        sceGxmShaderPatcherRegisterProgram(shader_patcher, shader->vert_gxp, &shader->vert_id);
        sceGxmProgramCheck(shader->vert_gxp);

        if (psv_mpv_dump_shaders)
            dumpShader(vshader, "Vert", shader->vert_gxp, size);
    }

    if (fshader != NULL) {
        uint32_t size = strlen(fshader);
        SceGxmProgram *p = shark_compile_shader(fshader, &size, SHARK_FRAGMENT_SHADER);
        if (!p) {
            shark_clear_output();
            return 0;
        }
        shader->frag_gxp = (SceGxmProgram *) malloc(size);
        sceClibMemcpy((void *) shader->frag_gxp, (void *) p, size);
        shark_clear_output();
        sceGxmShaderPatcherRegisterProgram(shader_patcher, shader->frag_gxp, &shader->frag_id);
        sceGxmProgramCheck(shader->frag_gxp);

        if (psv_mpv_dump_shaders)
            dumpShader(fshader, "Frag", shader->frag_gxp, size);
    }
    return 1;
}
#else
struct ShaderBinary {
    const char *sha;
    const unsigned char *data;
};

static SceGxmProgram *mpv_get_shader(const char *source) {
    static const unsigned char default_frag_shader[556] = {
	    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x00, 0x03, 0x29, 0x02, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08,
	    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x11, 0x01, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x4c, 0x01, 0x00, 0x00,
	    0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xd4, 0x00,
	    0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0xc4,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x90, 0x3a,
	    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x01,
	    0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00,
	    0x00, 0x01, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x3c, 0x01,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00,
	    0x02, 0xf1, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00,
	    0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0xf1, 0x00, 0x00, 0x01, 0x00,
	    0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
	    0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
	    0x30, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0xa0, 0x84, 0x20, 0x83,
	    0xe8, 0x00, 0x00, 0x80, 0xa0, 0x84, 0x20, 0x83, 0xe8, 0x00, 0x02,
	    0xe0, 0xa0, 0x84, 0x20, 0x83, 0xe8, 0x00, 0x06, 0x40, 0xa1, 0x84,
	    0x20, 0x83, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xf9,
	    0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x04, 0xf8, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x44, 0xfa, 0x00, 0x00,
	    0x00, 0x00, 0x40, 0x09, 0x00, 0xf8, 0xc2, 0x80, 0x28, 0xef, 0x84,
	    0x0b, 0xc0, 0x08, 0x06, 0x82, 0xa1, 0xff, 0x9c, 0x0d, 0xc0, 0x40,
	    0x04, 0x00, 0x11, 0x9f, 0x80, 0x8b, 0xb1, 0x18, 0x03, 0xc0, 0xa2,
	    0xff, 0x9c, 0x0d, 0xc0, 0x40, 0x00, 0x00, 0x11, 0x9f, 0x80, 0x8b,
	    0xb1, 0x18, 0x0c, 0x85, 0xa1, 0xff, 0x9c, 0x0d, 0xc0, 0x40, 0x3d,
	    0x1f, 0x04, 0x0f, 0x84, 0xf7, 0xc0, 0x08, 0x00, 0xbc, 0x19, 0x20,
	    0x7e, 0x0d, 0x81, 0x40, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x80, 0x00,
	    0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00,
	    0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x94, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x02, 0x04, 0x01, 0x00, 0x01,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
	    0x02, 0x04, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	    0x00, 0x5c, 0x00, 0x00, 0x00, 0x02, 0x04, 0x01, 0x00, 0x01, 0x00,
	    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x03, 0x01,
	    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x6d,
	    0x61, 0x74, 0x72, 0x69, 0x78, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72,
	    0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x5f, 0x63, 0x00, 0x74, 0x65,
	    0x78, 0x74, 0x75, 0x72, 0x65, 0x30, 0x00, 0x74, 0x65, 0x78, 0x74,
	    0x75, 0x72, 0x65, 0x31, 0x00, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72,
	    0x65, 0x32, 0x00, 0x00, 0x00, 0x00
    };

    static const unsigned char default_vert_shader[372] = {
	    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x00, 0x03, 0x73, 0x01, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	    0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00,
	    0x70, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x80, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x70,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x90, 0x3a,
	    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0a,
	    0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
	    0x44, 0xfa, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x10, 0xfa, 0x80,
	    0x00, 0x08, 0x83, 0x21, 0x25, 0x80, 0x38, 0x01, 0x00, 0x04, 0x90,
	    0x85, 0x11, 0xa5, 0x08, 0x01, 0x80, 0x56, 0x90, 0x81, 0x11, 0x83,
	    0x08, 0x00, 0x00, 0x20, 0xa0, 0x00, 0x50, 0x27, 0xfb, 0x40, 0x00,
	    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0e, 0x00,
	    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00,
	    0x00, 0x00, 0x04, 0x0e, 0x01, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00,
	    0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0e, 0x02, 0x01,
	    0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x76, 0x65, 0x72, 0x74,
	    0x65, 0x78, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	    0x00, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x5f, 0x74, 0x65, 0x78,
	    0x63, 0x6f, 0x6f, 0x72, 0x64, 0x30, 0x00, 0x76, 0x65, 0x72, 0x74,
	    0x65, 0x78, 0x5f, 0x74, 0x65, 0x78, 0x63, 0x6f, 0x6f, 0x72, 0x64,
	    0x31, 0x00, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x5f, 0x74, 0x65,
	    0x78, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x32, 0x00, 0x00
    };

    static const unsigned char osd_frag_shader[292] = {
        0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x00, 0x03, 0x23, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x18,
        0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc4, 0x00, 0x00, 0x00,
        0x70, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x84, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x74,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x90, 0x3a,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x64, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x04, 0x01, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x00, 0xa9, 0xd0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x07, 0x44, 0xfa, 0x00, 0x00, 0x00, 0x00, 0x40,
        0x09, 0x00, 0xf8, 0x02, 0x80, 0x99, 0xaf, 0xbc, 0x0d, 0xc0, 0x40,
        0x80, 0x00, 0xf4, 0x81, 0x00, 0x05, 0x80, 0x38, 0x7c, 0x8f, 0x36,
        0x00, 0x8a, 0x47, 0x80, 0x10, 0x30, 0x00, 0x00, 0x00, 0x02, 0x04,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0x73,
        0x64, 0x74, 0x65, 0x78, 0x00, 0x00
    };

    static const unsigned char osd_vert_shader[348] = {
	    0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x00, 0x03, 0x59, 0x01, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	    0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00,
	    0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x80, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x70,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x3a,
	    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x33, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x0a,
	    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
	    0x44, 0xfa, 0x01, 0x0e, 0x01, 0x01, 0x02, 0x00, 0x10, 0xfa, 0x80,
	    0x00, 0x08, 0x83, 0x21, 0x25, 0x80, 0x38, 0x01, 0x01, 0x01, 0x01,
	    0x00, 0x00, 0x10, 0xfa, 0x01, 0x00, 0x04, 0x90, 0x85, 0x11, 0xa5,
	    0x08, 0x01, 0x80, 0x56, 0x90, 0x81, 0x11, 0x83, 0x08, 0x00, 0x00,
	    0x20, 0xa0, 0x00, 0x50, 0x27, 0xfb, 0x30, 0x00, 0x00, 0x00, 0x00,
	    0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x30, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0e, 0x00, 0x01, 0x00, 0x00,
	    0x00, 0x04, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x04,
	    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x76,
	    0x65, 0x72, 0x74, 0x65, 0x78, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74,
	    0x69, 0x6f, 0x6e, 0x00, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x5f,
	    0x74, 0x65, 0x78, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x00, 0x76, 0x65,
	    0x72, 0x74, 0x65, 0x78, 0x5f, 0x61, 0x73, 0x73, 0x5f, 0x63, 0x6f,
	    0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00, 0x00
    };

    static const unsigned char clear_vert_shader[252] = {
        0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x00, 0x03, 0xf9, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00,
        0x70, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x70,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x90, 0x3a,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
        0x44, 0xfa, 0x01, 0x00, 0x04, 0x90, 0x85, 0x11, 0xa5, 0x08, 0x01,
        0x80, 0x56, 0x90, 0x81, 0x11, 0x83, 0x08, 0x00, 0x00, 0x20, 0xa0,
        0x00, 0x50, 0x27, 0xfb, 0x10, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x6f,
        0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00
    };

    static const unsigned char clear_frag_shader[228] = {
        0x47, 0x58, 0x50, 0x00, 0x01, 0x05, 0x00, 0x03, 0xe2, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x18, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00,
        0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x74, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x64,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x90, 0x3a,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x44,
        0xfa, 0x02, 0x80, 0x19, 0xf0, 0x7e, 0x0d, 0x80, 0x40, 0x0e, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01,
        0xe4, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x00
    };

    static struct ShaderBinary shaders_list[6] = {
        {"0EE8D1AE0AE179C02B2372CEAAA330C021317011D06C6E73108E6DB3A3E309CE", clear_frag_shader},
        {"95886918248D9F48355D927B41713FDFF8B050244A2E40C3286CA498D533C843", clear_vert_shader},
        {"CF8FDF60F73F9078E522B537B4E34750D6D1E091652DC3B5EF6171897300C698", default_frag_shader},
        {"BAE766589C86E7D1AA3A7551963F891AAD40B457AD40161C80190CCFD8F04FCB", default_vert_shader},
        {"7C3E5E88B0B58AEB0D5DEB6FCD962ED89F5FA1A64A3DBACDB33040DF288D36F0", osd_frag_shader},
        {"D904B9CF40B42526D823C9339B8AB903F295903AA5FDDA6A1E74926100CC8DB3", osd_vert_shader},
    };

    char sha[65];
    mpv_get_shader_hash(source, sha);
    for(int i = 0; i < 6; i++) {
        if(strcmp(sha, shaders_list[i].sha) == 0) {
            return (SceGxmProgram *)shaders_list[i].data;
        }
    }

    return NULL;
}

static int gxm_create_shader(GxmShaderProgram *shader, SceGxmShaderPatcher *shader_patcher, const char *vshader, const char *fshader) {
    if (vshader != NULL) {
        shader->vert_gxp = mpv_get_shader(vshader);
        if (!shader->vert_gxp)
            return 0;
        sceGxmShaderPatcherRegisterProgram(shader_patcher, shader->vert_gxp, &shader->vert_id);
        sceGxmProgramCheck(shader->vert_gxp);
    }

    if (fshader != NULL) {
        shader->frag_gxp = mpv_get_shader(fshader);
        if (!shader->frag_gxp)
            return 0;
        sceGxmShaderPatcherRegisterProgram(shader_patcher, shader->frag_gxp, &shader->frag_id);
        sceGxmProgramCheck(shader->frag_gxp);
    }
    return 1;
}
#endif

static void gxm_delete_shader(GxmShaderProgram *prog, SceGxmShaderPatcher *shader_patcher) {
    if (shader_patcher == NULL)
        return;

    if (prog->vert)
        sceGxmShaderPatcherReleaseVertexProgram(shader_patcher, prog->vert);
    if (prog->frag)
        sceGxmShaderPatcherReleaseFragmentProgram(shader_patcher, prog->frag);

    if (prog->vert_id)
        sceGxmShaderPatcherUnregisterProgram(shader_patcher, prog->vert_id);
    if (prog->frag_id)
        sceGxmShaderPatcherUnregisterProgram(shader_patcher, prog->frag_id);

#if HAVE_VITASHARK
    if (prog->vert_gxp)
        free(prog->vert_gxp);
    if (prog->frag_gxp)
        free(prog->frag_gxp);
#endif
}

struct gxm_vao {
    SceUID uid;
    float *buffer;
    int stride;     // size of each element (interleaved elements are assumed)
    const struct ra_renderpass_input *entries;
    int num_entries;
};

struct ra_renderpass_gxm {
    GxmShaderProgram prog;
    SceUID vertices_uid;
    float *vertices;
    const SceGxmProgramParameter **uniform_loc;
    int num_uniform_loc;

    float *uniform_buffer;
    SceUID uniform_uid;
};


static void gxm_tex_destroy(struct ra *ra, struct ra_tex *tex) {
    if (!tex)
        return;
    talloc_free(tex);
}

static struct ra_tex *gxm_tex_create(struct ra *ra,
                                 const struct ra_tex_params *params) {
    if (params->downloadable)
        return NULL;

    int ret;
    struct ra_tex *tex = talloc_zero(NULL, struct ra_tex);
    if (!tex) {
        goto error;
    }

    assert(params->format != NULL);
    const struct gxm_format *fmt = params->format->priv;
    int aligned_width = MP_ALIGN_UP(params->w, 8);
    int tex_size = aligned_width * params->h * fmt->bytes;
    const unsigned char * data = params->initial_data;
    tex->params = *params;
    tex->params.initial_data = NULL;

    struct ra_tex_gxm *tex_gxm = tex->priv = talloc_zero(tex, struct ra_tex_gxm);
    if (!tex_gxm) {
        goto error;
    }

    tex_gxm->tex_data = (uint8_t *) gxm_alloc(SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
                                                  SCE_GXM_MEMORY_ATTRIB_RW,
                                                  tex_size,
                                                  &tex_gxm->data_UID);
    if (tex_gxm->tex_data == NULL) {
        goto error;
    }

    if (data == NULL) {
        memset(tex_gxm->tex_data, 0, tex_size);
    } else {
        for (int i = 0; i < params->h; i++) {
            memcpy(tex_gxm->tex_data + i * aligned_width, data + i * params->w * fmt->bytes, params->w * fmt->bytes);
        }
    }

    ret = sceGxmTextureInitLinear(&tex_gxm->gxm_tex, tex_gxm->tex_data, fmt->format,
                                  aligned_width, params->h, 0);
    if (ret < 0) {
        gxm_free(tex_gxm->data_UID);
        tex_gxm->data_UID = 0;
        goto error;
    }

    SceGxmTextureFilter filter = params->src_linear ? SCE_GXM_TEXTURE_FILTER_LINEAR : SCE_GXM_TEXTURE_FILTER_POINT;
    sceGxmTextureSetMinFilter(&tex_gxm->gxm_tex, filter);
    sceGxmTextureSetMagFilter(&tex_gxm->gxm_tex, filter);

    SceGxmTextureAddrMode wrap = params->src_repeat ? SCE_GXM_TEXTURE_ADDR_REPEAT : SCE_GXM_TEXTURE_ADDR_CLAMP;
    sceGxmTextureSetUAddrMode(&tex_gxm->gxm_tex, wrap);
    sceGxmTextureSetVAddrMode(&tex_gxm->gxm_tex, wrap);

    tex_gxm->format = fmt->format;
    tex_gxm->bpp = fmt->bytes;
    tex_gxm->stride = aligned_width;
    return tex;
    error:
    gxm_tex_destroy(ra, tex);
    return NULL;
}


static bool gxm_tex_upload(struct ra *ra, const struct ra_tex_upload_params *params) {
    struct ra_tex *tex = params->tex;
    struct ra_tex_gxm *tex_gxm = tex->priv;
    const void *src = params->src;
    assert(tex->params.host_mutable);
    if (!src)
        return false;

    switch (tex->params.dimensions) {
        case 2: {
            struct mp_rect rc = {0, 0, tex->params.w, tex->params.h};
            if (params->rc)
                rc = *params->rc;
            for (int i = 0; i < rc.y1 - rc.y0; i++) {
                int h_offset  = rc.x0 * tex_gxm->bpp;
                int texture_start = (i + rc.y0) * tex_gxm->stride + h_offset;
                int src_start = (i + rc.y0) * params->stride + h_offset;
                memcpy(tex_gxm->tex_data + texture_start, (uint8_t *)src + src_start, (rc.x1 - rc.x0) * tex_gxm->bpp);
            }
            break;
        }
        default:
            MP_ASSERT_UNREACHABLE();
    }

    return true;
}

static bool gxm_tex_download(struct ra *ra, struct ra_tex_download_params *params) {
    return false;
}

static void gxm_buf_destroy(struct ra *ra, struct ra_buf *buf) {
    MP_ASSERT_UNREACHABLE();
}

static struct ra_buf *gxm_buf_create(struct ra *ra,
                                 const struct ra_buf_params *params) {
    MP_ASSERT_UNREACHABLE();
    return NULL;
}


static void gxm_buf_update(struct ra *ra, struct ra_buf *buf, ptrdiff_t offset,
                       const void *data, size_t size) {
    MP_ASSERT_UNREACHABLE();
}


static void gxm_clear(struct ra *ra, struct ra_tex *tex, float color[4],
                  struct mp_rect *rc) {
    struct ra_gxm *gxm = ra->priv;
    sceGxmSetVertexProgram(gxm->context, gxm->clearProg.vert);
    sceGxmSetFragmentProgram(gxm->context, gxm->clearProg.frag);

    sceGxmSetVertexStream(gxm->context, 0, gxm->clearVertices);

    void *buffer;
    sceGxmReserveFragmentDefaultUniformBuffer(gxm->context, &buffer);
    sceGxmSetUniformDataF(buffer, gxm->clearParam, 0, 4, color);

    sceGxmSetRegionClip(gxm->context, SCE_GXM_REGION_CLIP_OUTSIDE, rc->x0, rc->y0, rc->x1, rc->y1);
    sceGxmDraw(gxm->context,
               SCE_GXM_PRIMITIVE_TRIANGLES,
               SCE_GXM_INDEX_FORMAT_U16,
               gxm->linearIndices,
               3);
}


static void gxm_blit(struct ra *ra, struct ra_tex *dst, struct ra_tex *src,
                 struct mp_rect *dst_rc_ptr, struct mp_rect *src_rc_ptr) {
    assert(src->params.blit_src);
    assert(dst->params.blit_dst);

}

static int gxm_desc_namespace(struct ra *ra, enum ra_vartype type) {
    return type;
}

static void gxm_renderpass_destroy(struct ra *ra, struct ra_renderpass *pass) {
    if (!pass)
        return;
    struct ra_renderpass_gxm *pass_p = pass->priv;
    struct ra_gxm *gxm = ra->priv;

    sceGxmFinish(gxm->context);
    gxm_free(pass_p->vertices_uid);
    gxm_free(pass_p->uniform_uid);
    gxm_delete_shader(&pass_p->prog, gxm->shader_patcher);
    talloc_free(pass);
}

static SceGxmBlendFactor map_ra_blend(enum ra_blend blend)
{
    switch (blend) {
        case RA_BLEND_ZERO:                return SCE_GXM_BLEND_FACTOR_ZERO;
        case RA_BLEND_ONE:                 return SCE_GXM_BLEND_FACTOR_ONE;
        case RA_BLEND_SRC_ALPHA:           return SCE_GXM_BLEND_FACTOR_SRC_ALPHA;
        case RA_BLEND_ONE_MINUS_SRC_ALPHA: return SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    }
    MP_ASSERT_UNREACHABLE();
}

static SceGxmAttributeFormat map_vertex_type(enum ra_vartype type) {
    switch (type) {
        case RA_VARTYPE_FLOAT:
            return SCE_GXM_ATTRIBUTE_FORMAT_F32;
        case RA_VARTYPE_BYTE_UNORM:
            return SCE_GXM_ATTRIBUTE_FORMAT_U8N;
        default:
            MP_ASSERT_UNREACHABLE();
    }
}

static struct ra_renderpass *gxm_renderpass_create(struct ra *ra,
                                               const struct ra_renderpass_params *params) {
    struct ra_gxm *gxm = ra->priv;
    struct ra_renderpass *pass = talloc_zero(NULL, struct ra_renderpass);
    pass->params = *ra_renderpass_params_copy(pass, params);
    pass->params.cached_program = (bstr) {0};
    struct ra_renderpass_gxm *p = pass->priv = talloc_zero(pass, struct ra_renderpass_gxm);

//    sceClibPrintf("frag: %s\n\n", params->frag_shader);
//    sceClibPrintf("vert: %s\n\n", params->vertex_shader);
//    sceClibPrintf("comp: %p\n\n", params->compute_shader);

    if (params->type == RA_RENDERPASS_TYPE_COMPUTE) {
        MP_ASSERT_UNREACHABLE();
    }

    gxm_create_shader(&p->prog, gxm->shader_patcher, params->vertex_shader, params->frag_shader);
    if (p->prog.vert_gxp == NULL || p->prog.frag_gxp == NULL) {
        talloc_free(pass);
        return NULL;
    }

    SceGxmVertexAttribute *vertex_attribute = talloc_array(NULL, SceGxmVertexAttribute,
                                                                 pass->params.num_vertex_attribs);
    for (int i = 0; i < pass->params.num_vertex_attribs; i++) {
        struct ra_renderpass_input *inp = &pass->params.vertex_attribs[i];
        const SceGxmProgramParameter *param = sceGxmProgramFindParameterByName(p->prog.vert_gxp, inp->name);

        vertex_attribute[i].streamIndex = 0;
        vertex_attribute[i].offset = inp->offset;
        vertex_attribute[i].format = map_vertex_type(inp->type);
        vertex_attribute[i].componentCount = inp->dim_m * inp->dim_v;
        vertex_attribute[i].regIndex = sceGxmProgramParameterGetResourceIndex(param);
    }

    //todo: 根据实际顶点数设置大小
    p->vertices = (float *) gxm_alloc(
            SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
            SCE_GXM_MEMORY_ATTRIB_READ,
            pass->params.vertex_stride * MAX_VERTEX_POINTS,
            &p->vertices_uid);

    SceGxmVertexStream vertex_stream[1];
    vertex_stream[0].stride = pass->params.vertex_stride;
    vertex_stream[0].indexSource = SCE_GXM_INDEX_SOURCE_INDEX_16BIT;

    SceGxmBlendInfo *blendInfo = NULL, _blendInfo;;

    if (params->enable_blend) {
        _blendInfo.colorMask = SCE_GXM_COLOR_MASK_ALL;
        _blendInfo.colorFunc = SCE_GXM_BLEND_FUNC_ADD;
        _blendInfo.alphaFunc = SCE_GXM_BLEND_FUNC_ADD;
        _blendInfo.colorSrc = map_ra_blend(params->blend_src_rgb);
        _blendInfo.colorDst = map_ra_blend(params->blend_dst_rgb);
        _blendInfo.alphaSrc = map_ra_blend(params->blend_src_alpha);
        _blendInfo.alphaDst = map_ra_blend(params->blend_dst_alpha);
        blendInfo = &_blendInfo;
    }

    sceGxmShaderPatcherCreateVertexProgram(
            gxm->shader_patcher, p->prog.vert_id,
            vertex_attribute, pass->params.num_vertex_attribs,
            vertex_stream, sizeof(vertex_stream) / sizeof(SceGxmVertexStream),
            &p->prog.vert);

    sceGxmShaderPatcherCreateFragmentProgram(
            gxm->shader_patcher, p->prog.frag_id,
            SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4, gxm->msaa,
            blendInfo, p->prog.vert_gxp,
            &p->prog.frag);

    talloc_free(vertex_attribute);

    int uniform_size = 0;
    for (int n = 0; n < pass->params.num_inputs; n++) {
        const SceGxmProgramParameter *loc = sceGxmProgramFindParameterByName(p->prog.frag_gxp, params->inputs[n].name);
        MP_TARRAY_APPEND(p, p->uniform_loc, p->num_uniform_loc, loc);
        if (pass->params.inputs[n].type == RA_VARTYPE_INT || pass->params.inputs[n].type == RA_VARTYPE_FLOAT) {
            uniform_size += MP_ALIGN_UP(pass->params.inputs[n].dim_m * pass->params.inputs[n].dim_v, 4);
        }
    }

    p->uniform_buffer = (float *) gxm_alloc(
            SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
            SCE_GXM_MEMORY_ATTRIB_READ,
            sizeof(float) * uniform_size,
            &p->uniform_uid);
    sceGxmSetFragmentUniformBuffer(gxm->context, gxm->buffer_index, p->uniform_buffer);

    return pass;
}

static void gxm_renderpass_run(struct ra *ra,
                           const struct ra_renderpass_run_params *params) {
    struct ra_gxm *gxm = ra->priv;
    struct ra_renderpass *pass = params->pass;
    enum ra_renderpass_type type = pass->params.type;
    struct ra_renderpass_gxm *p = pass->priv;

    assert(type != RA_RENDERPASS_TYPE_COMPUTE);

    sceGxmSetVertexProgram(gxm->context, p->prog.vert);
    sceGxmSetFragmentProgram(gxm->context, p->prog.frag);
    memcpy(p->vertices, params->vertex_data, pass->params.vertex_stride * params->vertex_count);
    sceGxmSetVertexStream(gxm->context, 0, p->vertices);
    sceGxmSetFragmentUniformBuffer(gxm->context, gxm->buffer_index, p->uniform_buffer);

    for (int n = 0; n < params->num_values; n++) {
        struct ra_renderpass_input_val *val = &params->values[n];
        struct ra_renderpass_input *input = &pass->params.inputs[val->index];
        const SceGxmProgramParameter *loc = p->uniform_loc[val->index];

        switch (input->type) {
            case RA_VARTYPE_INT:
            //todo 检查int值的作用
            case RA_VARTYPE_FLOAT: {
                if (!loc)
                    break;
                float *f = val->data;
                sceGxmSetUniformDataF(p->uniform_buffer, loc, 0, input->dim_v * input->dim_m, f);
                break;
            }
            case RA_VARTYPE_TEX: {
                struct ra_tex *tex = *(struct ra_tex **) val->data;
                struct ra_tex_gxm *tex_gxm = tex->priv;
                assert(tex->params.render_src);
                sceGxmSetFragmentTexture(gxm->context, input->binding, &tex_gxm->gxm_tex);
                break;
            }
            case RA_VARTYPE_IMG_W:
            case RA_VARTYPE_BUF_RO:
            case RA_VARTYPE_BUF_RW:
            default:
                MP_ASSERT_UNREACHABLE();
        }
    }

    sceGxmDraw(gxm->context, SCE_GXM_PRIMITIVE_TRIANGLES, SCE_GXM_INDEX_FORMAT_U16, gxm->linearIndices,
               params->vertex_count);
}

static void gxm_timer_destroy(struct ra *ra, ra_timer *ratimer) {
    if (!ratimer)
        return;
    struct gxm_timer *timer = ratimer;
    talloc_free(timer);
}

static ra_timer *gxm_timer_create(struct ra *ra) {
    return NULL;
}

static void gxm_timer_start(struct ra *ra, ra_timer *ratimer) {
}

static uint64_t gxm_timer_stop(struct ra *ra, ra_timer *ratimer) {
    return 0;
}


static void gxm_debug_marker(struct ra *ra, const char *msg) {
}

static void gxm_destroy(struct ra *ra) {
    struct ra_gxm *gxm = ra->priv;
    sceGxmFinish(gxm->context);
    gxm_free(gxm->linearIndicesUid);
    gxm_free(gxm->clearVerticesUid);
    gxm_delete_shader(&gxm->clearProg, gxm->shader_patcher);

    talloc_free(ra);
}

static struct ra_fns ra_fns_gxm = {
        .destroy            = gxm_destroy,
        .tex_create         = gxm_tex_create,
        .tex_destroy        = gxm_tex_destroy,
        .tex_upload         = gxm_tex_upload,
        .tex_download       = gxm_tex_download,
        .buf_create         = gxm_buf_create,
        .buf_destroy        = gxm_buf_destroy,
        .buf_update         = gxm_buf_update,
        .clear              = gxm_clear,
        .blit               = gxm_blit,
        .uniform_layout     = std140_layout,
        .desc_namespace     = gxm_desc_namespace,
        .renderpass_create  = gxm_renderpass_create,
        .renderpass_destroy = gxm_renderpass_destroy,
        .renderpass_run     = gxm_renderpass_run,
        .timer_create       = gxm_timer_create,
        .timer_destroy      = gxm_timer_destroy,
        .timer_start        = gxm_timer_start,
        .timer_stop         = gxm_timer_stop,
        .debug_marker       = gxm_debug_marker,
};


struct ra * ra_gxm_create(struct mp_log *log, SceGxmContext *context, SceGxmShaderPatcher *shader_patcher,
                          int buffer_index, SceGxmMultisampleMode msaa) {
    struct ra *ra = talloc_zero(NULL, struct ra);
    ra->log = log;
    ra->fns = &ra_fns_gxm;

    ra->glsl_version = 200;
    ra->glsl_gxm = true;
    ra->gxm_buffer_index = buffer_index;

    ra->caps = RA_CAP_DIRECT_UPLOAD | RA_CAP_GLOBAL_UNIFORM;

    struct ra_gxm *p = ra->priv = talloc_zero(ra, struct ra_gxm);
    p->context = context;
    p->shader_patcher = shader_patcher;
    p->buffer_index = buffer_index;
    p->msaa = msaa;

    ra->max_texture_wh = 1920;

    for (int i = 0; i < MP_ARRAY_SIZE(gxm_formats); ++i) {
        const struct gxm_format *gxmfmt = &gxm_formats[i];

        struct ra_format *fmt = talloc_zero(ra, struct ra_format);
        *fmt = (struct ra_format) {
                .name           = gxmfmt->name,
                .priv           = (void *) gxmfmt,
                .ctype          = gxmfmt->ctype,
                .ordered        = gxmfmt->ordered,
                .num_components = gxmfmt->components,
                .pixel_size     = gxmfmt->bytes,
                .linear_filter  = gxmfmt->linear_filter,
                .renderable     = gxmfmt->renderable,
                .storable       = gxmfmt->storable,
        };

        for (int j = 0; j < gxmfmt->components; j++)
            fmt->component_size[j] = fmt->component_depth[j] = gxmfmt->bits[j];

        fmt->glsl_format = ra_fmt_glsl_format(fmt);

        MP_TARRAY_APPEND(ra, ra->formats, ra->num_formats, fmt);
    }

    // Create shared linear index buffer
    p->linearIndices = (unsigned short *) gxm_alloc(
        SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
        SCE_GXM_MEMORY_ATTRIB_READ,
        MAX_VERTEX_POINTS * sizeof(unsigned short),
        &p->linearIndicesUid);

    for (uint32_t i = 0; i < MAX_VERTEX_POINTS; ++i) {
        p->linearIndices[i] = i;
    }

    // Create clear shader
    static const char *clearVertShader = "float4 main(float2 position) : POSITION\n"
                                         "{\n"
                                         "	return float4(position, 1.f, 1.f);\n"
                                         "}\n";

    static const char *clearFragShader = "__nativecolor __regformat unsigned char4 main(uniform float4 color) : COLOR\n"
                                         "{\n"
                                         "	return unsigned char4(color * 255);\n"
                                         "}\n";

    gxm_create_shader(&p->clearProg, p->shader_patcher, clearVertShader,clearFragShader);

    p->clearVertices = (struct mp_gxm_clear_vertex *) gxm_alloc(
            SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
            SCE_GXM_MEMORY_ATTRIB_READ,
            3 * sizeof(struct mp_gxm_clear_vertex),
            &p->clearVerticesUid);
    p->clearVertices[0] = (struct mp_gxm_clear_vertex) {-1.0f, -1.0f};
    p->clearVertices[1] = (struct mp_gxm_clear_vertex) {3.0f, -1.0f};
    p->clearVertices[2] = (struct mp_gxm_clear_vertex) {-1.0f, 3.0f};
    p->clearParam = sceGxmProgramFindParameterByName(p->clearProg.frag_gxp, "color");

    const SceGxmProgramParameter *clear_position_param = sceGxmProgramFindParameterByName(
            p->clearProg.vert_gxp,
            "position");
    SceGxmVertexAttribute clear_vertex_attribute;
    clear_vertex_attribute.streamIndex = 0;
    clear_vertex_attribute.offset = 0;
    clear_vertex_attribute.format = SCE_GXM_ATTRIBUTE_FORMAT_F32;
    clear_vertex_attribute.componentCount = 2;
    clear_vertex_attribute.regIndex = sceGxmProgramParameterGetResourceIndex(clear_position_param);

    SceGxmVertexStream clear_vertex_stream;
    clear_vertex_stream.stride = sizeof(struct mp_gxm_clear_vertex);
    clear_vertex_stream.indexSource = SCE_GXM_INDEX_SOURCE_INDEX_16BIT;

    sceGxmShaderPatcherCreateVertexProgram(
            p->shader_patcher, p->clearProg.vert_id,
            &clear_vertex_attribute, 1,
            &clear_vertex_stream, 1,
            &p->clearProg.vert);

    sceGxmShaderPatcherCreateFragmentProgram(
            p->shader_patcher, p->clearProg.frag_id,
            SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4, SCE_GXM_MULTISAMPLE_NONE,
            NULL, p->clearProg.vert_gxp,
            &p->clearProg.frag);
    return ra;
}


bool ra_is_gxm(struct ra *ra) {
    return ra->fns == &ra_fns_gxm;
}
